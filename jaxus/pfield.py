from functools import partial

import jax
import jax.numpy as jnp
import numpy as np
from jax import jit


@partial(jit, static_argnames=("n_freqs", "reduce"))
def compute_pfield(
    pixels,
    probe_geometry,
    t0_delays,
    tx_apodizations,
    center_frequency,
    band,
    element_width,
    sound_speed,
    n_freqs,
    reduce=False,
):
    """Computes the pressure field generated by the given delays."""

    bandwidth = band[1] - band[0]

    spect = get_pulse_spectrum_fn(fc=center_frequency, n_period=1)
    transducer_bw = get_transducer_bandwidth_fn(
        fc=center_frequency, bandwidth=bandwidth * 1.5
    )

    distances = jnp.linalg.norm(
        pixels[None, :, :] - probe_geometry[:, None, :], axis=-1
    )

    delay = distances / sound_speed

    # Compute angle between element and pixel (n_el, n_pixels)
    theta = jnp.abs(
        jnp.arctan2(
            pixels[None, :, 0] - probe_geometry[:, None, 0],
            pixels[None, :, 1] - probe_geometry[:, None, 1],
        )
    )

    freqs = jnp.linspace(band[0], band[1], n_freqs)
    delta_freq = freqs[1] - freqs[0]

    arg = 2 * jnp.pi * (delay + t0_delays[:, None])
    phase = jnp.mod(arg * freqs[0], 2 * jnp.pi)
    delta_phase = jnp.exp(1j * arg * delta_freq)
    phase = jnp.exp(1j * phase - 100 * 0.5 * distances)

    def scanfn(carry, _):
        phase, freq = carry

        wavelength = sound_speed / freq

        # Compute the directivity
        directivity = jnp.sinc(element_width / wavelength * jnp.sin(theta)) * jnp.cos(
            theta
        )

        # Compute the received signal
        signal = jnp.sum(
            phase
            * directivity
            * spect(freq)
            * transducer_bw(freq)
            * tx_apodizations[:, None],
            axis=0,
        )

        phase = phase * delta_phase
        freq = freq + delta_freq
        phase = phase

        return (phase, freq), jnp.abs(signal)

    _, pfield = jax.lax.scan(scanfn, (phase, freqs[0]), None, length=len(freqs))

    if reduce:
        return jnp.sum(pfield, axis=0)

    return pfield


def hann(x, width):
    """Hann window function.

    Parameters
    ----------
    x : array-like
        The input values.
    width : float
        The width of the window. This is the total width from -x to x. The window will
        be nonzero in the range [-width/2, width/2].

    Returns
    -------
    hann_vals : array-like
        The values of the Hann window function.
    """
    return jnp.where(
        jnp.abs(x) < width / 2, 1 / width * jnp.cos(np.pi * x / width) ** 2, 0
    )


def hann_unnormalized(x, width):
    """Hann window function.

    Parameters
    ----------
    x : array-like
        The input values.
    width : float
        The width of the window. This is the total width from -x to x. The window will
        be nonzero in the range [-width/2, width/2].

    Returns
    -------
    hann_vals : array-like
        The values of the Hann window function.
    """
    return jnp.where(jnp.abs(x) < width / 2, jnp.cos(np.pi * x / width) ** 2, 0)


def hann_fd(f, width):
    """The fourier transform of a hann window in the time domain with ."""
    denom = jnp.where(jnp.abs(f * width) < 1e-6, 1e-6, 1 - (f * width) ** 2)
    return 0.5 * jnp.sinc(f * width) / denom


def td_hann_fd(f, width_s):
    """The fourier transform of a hann window in the time domain with ."""
    return 0.5 * jnp.sinc(f * width_s) / (1 - (f * width_s) ** 2)


# def fd_hann_fd(f)


def get_pulse_spectrum_fn(fc, n_period=3):
    """Computes the spectrum of a sine that is windowed with a Hann window.

    Parameters
    ----------
    fc : float
        The center frequency of the pulse.
    n_period : float
        The number of periods to include in the pulse.

    Returns
    -------
    spectrum_fn : callable
        A function that computes the spectrum of the pulse for the input frequencies
        in Hz.
    """
    period = n_period / fc

    def spectrum_fn(f):
        return 1 / 1j * (hann_fd(f - fc, period) - hann_fd(f + fc, period))

    return spectrum_fn


def get_transducer_bandwidth_fn(fc, bandwidth):
    """Computes the spectrum of a probe with a center frequency and bandwidth.

    Parameters
    ----------
    fc : float
        The center frequency of the probe.
    bandwidth : float
        The bandwidth of the probe.

    Returns
    -------
    spectrum_fn : callable
        A function that computes the spectrum of the pulse for the input frequencies
        in Hz.
    """

    def bandwidth_fn(f):
        return hann_unnormalized(jnp.abs(f) - fc, bandwidth)

    return bandwidth_fn
